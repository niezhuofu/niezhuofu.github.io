[{"title":"随记","url":"/2019/07/12/随记/","content":"\n失眠. 乱七八糟的念头纷至沓来. 大多不清晰,仅仅一晃而过.却只有一个念头让我记忆深刻, 赶忙着记下来.问题大概是希望自己对你而言意味着什么.<br>\n大脑大约宕机了6 - 7 秒. 而后反应过来, 约莫是想法把自己也给逗乐了. <br>\n我大概会说：\n\n        我希望成为你无法用任何文字言语描述和记录下来的人, 只存在于你一言一行的影子中.\n\n记录完毕, 希望能再补上两小时的睡眠. <br>\n希望你一夜无梦, 安然的迎接新一个清晨.","tags":["日记"]},{"title":"Hello World","url":"/2019/06/11/hello-world/","content":"\n# Start\n        class Nzf{\n            public static void main(String arg[]){\n                System.println(\"hello world!\");\n            };\n        }\n\n这是学习开发的第一段代码。 hello world! 你好，世界！<br>\nhello，第一次打招呼，也如初见一个新奇的世界。<br>\n\n## loding...\n学习的过程是枯燥的。耐心、毅力以及那么一点点天赋，凑巧需要的目前为止我都有。曾以为我需要时间去消化去接受，始料未及的是如此自然的就像开始了蜜月期。迫切的想要去探索那些未知，理智却清晰的告诉自己需要冷静、分析。然而很多行为习惯不由自主、未经任何思考下意识反应出来。让我显得是如此的笨拙，像个初哥。<br>\n\n求知欲和好奇心以及冒险精神一直以来都在很多方面带给我积极的发展。但是，这是第一次让我感觉到了折磨。想知道的很多，无从说起也不该由我说起。在之前有很多遍询问自己，为什么会想要去了解，控制欲？直到某天早上醒来，看着那张安静的脸，恍然大悟，我只是想我选择的、了解的是完整的你。<br>\n就像不只是拿着框架生搬硬套、不只是复制粘贴。我想学会完整的去经营、优化我的逻辑、思维、行为以及计划。或许过程中会有挫折、错误。我都想一一接受、一一解决。\n       \n        class Nzf{\n            public static void main(String arg[]){\n                    System.println(\"hello world!\");\n                    whlie(true){\n                        Glj u = new Glj();\n                        life(u)\n                    };\n            };\n        }\n\n        class Glj{\n\n        }\n      \n \n 这是我想写的，最傻逼、最幼稚、最没有水平的一段代码。就这样吧，不要有end。","tags":["日记"]},{"title":"混淆语法","url":"/2019/06/11/混淆语法/","content":"\n1. -include {filename}    从给定的文件中读取配置参数   \n2. -basedirectory {directoryname}    指定基础目录为以后相对的档案名称   \n3. -injars {class_path}    指定要处理的应用程序jar,war,ear和目录   \n4. -outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称   \n5. -libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件   \n6. -dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。   \n7. -dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。  \n8.    \n9. 保留选项   \n10. -keep {Modifier} {class_specification}    保护指定的类文件和类的成员   \n11. -keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好  \n12. -keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。   \n13. -keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）   \n14. -keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除）   \n15. -keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）   \n16. -printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件   \n17.    \n18. 压缩   \n19. -dontshrink    不压缩输入的类文件   \n20. -printusage {filename}   \n21. -dontwarn   如果有警告也不终止  \n22. -whyareyoukeeping {class_specification}       \n23.    \n24. 优化   \n25. -dontoptimize    不优化输入的类文件   \n26. -assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用   \n27. -allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员   \n28.    \n29. 混淆   \n30. -dontobfuscate    不混淆输入的类文件   \n31. -printmapping {filename}   \n32. -applymapping {filename}    重用映射增加混淆   \n33. -obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称   \n34. -overloadaggressively    混淆时应用侵入式重载   \n35. -useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆   \n36. -flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中   \n37. -repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中   \n38. -dontusemixedcaseclassnames    混淆时不会产生形形色色的类名   \n39. -keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and   \n40.    \n41. InnerClasses.   \n42. -renamesourcefileattribute {string}    设置源文件中给定的字符串常量  \n","tags":["Code"]}]